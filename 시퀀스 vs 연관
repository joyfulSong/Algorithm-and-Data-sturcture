1. 차이점
연관 컨테이너:map, set, hash_map, hash_set이 있습니다. 이것들은 "Key로 사용하는 값이 중복되지 않을 때" 사용함.
시퀀스 컨테이너: list, vector, deque. 원소 보관의 목적.
- 삽입 시 연관 컨테이너는 정렬해주므로 logN인 반면, 시퀀스 컨테이너는 N.
- 존재하는지 아닌지 알려면, 연관 컨테이너는 정렬이 되어있으므로 logN, 시퀀스컨테이너는 순차적으로 접근해야하므로 N

만약 중복되는 key를 사용할 때는 컨테이너의 앞에 "multi"를 붙인 multi_map, multi_set, hash_multimap, hash_multiset을 사용합니다. Key의 중복 허용 여부만 다를 뿐 사용방법은 같습니다.

2. 정렬하고 안하고.
map과 set 컨테이너는 자료를 정렬하여 저장합니다. 그래서 반복자로 저장된 데이터를 순회할 때 넣은 순서로 순회하지 않고 정렬된 순서대로 순회합니다. 
- map: <유일키, 내용물>로 저장됨. 
- set: 키하나만 가짐, 자동정렬됨, unordered_map보다 느림. 어디에 추가하냐가 목적이 아니라 존재하는지 아는것이 목적
- 속도가 중요하고 정렬 상관없다면 hash_map 사용. hash_set은 정렬 하지 않으며 자료를 저장합니다. 또 hash라는 자료구조를 사용함으로 검색 속도가 map, set에 비해 빠릅니다.
- unordered_set, unordered_map: Hash Table, 효율적인 탐색을 위한 자료구조로서 key를 value에 대응시킨다. 구현 방법은 여러가지. key와 value로 된 쌍을 저장
                                insert, erase, find가 O(1)로 수행됨
                        해시 함수가 있기 때문: 해시 함수는 임의의 길이의 문자열을 받아서 고정 문자열로 바꾸어주는 함수이다.
                        구조상 1~할당된 메모리 크기 까지의 값을 반환하도록 설계. a가 들어있는 곳이 있다면 a의 주소를 리턴해서 중복으로 넣지 않게 하나, 
                        b를 넣겠다고 한다면 a가 있는 곳의 주소도 줄 수 있게 되는, 같은 공간을 할당하는 경우가 생겨서 해시 충돌이 일어나게 됨. - 최악의 탐색 O(N), set, map은 최악의 경우 logN.
                         => Chaining 또는 Open Addressing으로 해결
                        따라서보통은 map, set을 쓰고, 최적화가 필요하다면 함수를 잘 설계해서 hash를 쓰자.
                        

3.하지만 검색이 빠르다라는 것만 생각하고 (hash_map은 해시 테이블을 사용하므로) 무분별하게 hash_map을 사용하면 안됩니다. 
컨테이너에 추가나 삭제를 하는 것은 list나 vector, deque가 hash_map보다 빠릅니다. 또 적은 요소를 저장하고 검색할 때는 vector나 list가 훨씬 빠를 수 있습니다. 
수천의 자료를 저장하여 검색을 하는 경우에 hash_map을 사용하는 것이 좋습니다.

--> hash_map을 사용하는 경우
1. 많은 자료를 저장하고, 검색 속도가 빨라야 한다.
2. 너무 빈번하게 자료를 삽입, 삭제 하지 않는다.

std::hash는 hashing 용이고, 실제로는 hash_map, hash_set을 써야하나, 이는 실무에서 밖에 못씀. 쓰려면 unordered map 써야함.
                                                                                                                                                                                                                                
